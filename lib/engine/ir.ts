import type { IRProgram, IRStatement } from "@/types/blocks";

export function createProgram(): IRProgram {
  return { declarations: [], setup: [], loop: [] };
}

export function addDeclarations(program: IRProgram, decls: string[]) {
  for (const d of decls) if (!program.declarations.includes(d)) program.declarations.push(d);
}

export function emitSetup(program: IRProgram, ...stmts: IRStatement[]) {
  program.setup.push(...stmts);
}

export function emitLoop(program: IRProgram, ...stmts: IRStatement[]) {
  program.loop.push(...stmts);
}

export function formatIR(program: IRProgram): string {
  const lines: string[] = [];
  lines.push("// Generated by Visual Block Engine");
  lines.push("");
  for (const d of program.declarations) lines.push(d);
  if (program.declarations.length) lines.push("");
  lines.push("void setup() {");
  lines.push(...indent(formatStatements(program.setup)));
  lines.push("}");
  lines.push("");
  lines.push("void loop() {");
  lines.push(...indent(formatStatements(program.loop)));
  lines.push("}");
  return lines.join("\n");
}

function formatStatements(stmts: IRStatement[]): string[] {
  const out: string[] = [];
  for (const s of stmts) {
    switch (s.kind) {
      case "Raw":
        out.push(s.code.endsWith(";") ? s.code : s.code + ";");
        break;
      case "PinMode":
        out.push(`pinMode(${s.pin}, ${s.mode});`);
        break;
      case "DigitalWrite":
        out.push(`digitalWrite(${s.pin}, ${s.value});`);
        break;
      case "AnalogWrite":
        out.push(`analogWrite(${s.pin}, ${s.value});`);
        break;
      case "SerialBegin":
        out.push(`Serial.begin(${s.baud});`);
        break;
      case "SerialPrint":
        out.push(`Serial.print${s.newLine ? "ln" : ""}(${s.value});`);
        break;
      case "ExpressionStatement":
        out.push(`${s.expression};`);
        break;
      case "Delay":
        out.push(`delay(${s.ms});`);
        break;
      case "Assignment":
        out.push(`${s.name} = ${s.value};`);
        break;
      case "If":
        out.push(`if (${s.condition}) {`);
        out.push(...indent(formatStatements(s.then)));
        out.push("}");
        if (s.else && s.else.length) {
          out.push("else {");
          out.push(...indent(formatStatements(s.else)));
          out.push("}");
        }
        break;
      case "While":
        out.push(`while (${s.condition}) {`);
        out.push(...indent(formatStatements(s.body)));
        out.push("}");
        break;
      case "For":
        out.push(`for (${s.init}; ${s.condition}; ${s.increment}) {`);
        out.push(...indent(formatStatements(s.body)));
        out.push("}");
        break;
      case "Repeat":
        out.push(`for (int ${s.indexVar} = 0; ${s.indexVar} < ${s.times}; ${s.indexVar}++) {`);
        out.push(...indent(formatStatements(s.body)));
        out.push("}");
        break;
    }
  }
  if (out.length === 0) return ["// No statements"];
  return out;
}

function indent(lines: string[], spaces = 2): string[] {
  const pad = " ".repeat(spaces);
  return lines.map((l) => (l.trim().length ? pad + l : l));
}
