import type { Graph, Node, NodeType } from "@/types/graph";
import { topologicalSort } from "@/utils/helpers";

/**
 * Arduino Code Generator
 * Converts visual node graphs into Arduino C++ code
 * 
 * Architecture:
 * 1. Analyze graph to determine pin modes (INPUT/OUTPUT)
 * 2. Topologically sort nodes to respect execution order
 * 3. Generate setup() function with pin initialization
 * 4. Generate loop() function with node operations
 */

/**
 * Analyze nodes and determine required pin modes
 */
function pinModes(nodes: Node[]): Map<number, "INPUT" | "OUTPUT"> {
  const pins = new Map<number, "INPUT" | "OUTPUT">();
  
  for (const n of nodes) {
    if (n.type === "DigitalWrite") {
      const pin = n.payload.pin;
      pins.set(pin, "OUTPUT");
    }
    if (n.type === "AnalogRead") {
      const pin = n.payload.pin;
      // Don't override if already set as OUTPUT
      if (!pins.has(pin)) {
        pins.set(pin, "INPUT");
      }
    }
  }
  
  return pins;
}

/**
 * Generate Arduino code for a single node
 */
function emitNode(n: Node): string {
  switch (n.type) {
    case "DigitalWrite": {
      const value = n.payload.value ? "HIGH" : "LOW";
      return `digitalWrite(${n.payload.pin}, ${value});  // ${n.id}`;
    }
    
    case "AnalogRead": {
      return `int ${n.id}_val = analogRead(${n.payload.pin});  // Read from A${n.payload.pin}`;
    }
    
    case "Delay": {
      return `delay(${n.payload.ms});  // Wait ${n.payload.ms}ms`;
    }
    
    case "If": {
      // TODO: Implement nested graph support for if-body
      return `if (${n.payload.condition}) {
    // TODO: Add nested nodes here
  }`;
    }
    
    case "Loop": {
      const iterations = n.payload.iterations || "infinite";
      return `// Loop marker: ${iterations} iterations`;
    }
    
    default: {
      // TypeScript will catch this at compile time due to exhaustive checking
      const _exhaustive: never = n;
      return `/* Unknown node type */`;
    }
  }
}

/**
 * Generate complete Arduino sketch from graph
 * 
 * @param graph - Node graph representation
 * @returns Arduino C++ code as string
 * 
 * @example
 * const graph = {
 *   nodes: [
 *     { id: "1", type: "DigitalWrite", payload: { pin: 13, value: true } },
 *     { id: "2", type: "Delay", payload: { ms: 1000 } }
 *   ],
 *   edges: [{ from: "1", to: "2" }]
 * };
 * 
 * const code = generateArduinoCode(graph);
 * // Output:
 * // void setup() {
 * //   pinMode(13, OUTPUT);
 * // }
 * // void loop() {
 * //   digitalWrite(13, HIGH);
 * //   delay(1000);
 * // }
 */
export function generateArduinoCode(graph: Graph): string {
  // Validate graph
  if (!graph.nodes || graph.nodes.length === 0) {
    return `// Empty graph - add nodes to generate code

void setup() {
  // Pin initialization will appear here
}

void loop() {
  // Your code will appear here
}`;
  }

  // Sort nodes by dependencies
  const sorted = topologicalSort(graph.nodes, graph.edges);
  
  // Determine required pin modes
  const pins = pinModes(graph.nodes);

  // Generate setup() function
  const setupLines: string[] = [];
  
  // Add serial communication if needed (for debugging)
  const hasAnalogRead = graph.nodes.some(n => n.type === "AnalogRead");
  if (hasAnalogRead) {
    setupLines.push("Serial.begin(9600);  // Initialize serial communication");
  }
  
  // Add pin mode configurations
  for (const [pin, mode] of pins) {
    setupLines.push(`pinMode(${pin}, ${mode});  // Configure pin ${pin}`);
  }
  
  if (setupLines.length === 0) {
    setupLines.push("// No pin configuration needed");
  }

  // Generate loop() function
  const loopLines: string[] = [];
  for (const n of sorted) {
    loopLines.push(emitNode(n));
  }
  
  if (loopLines.length === 0) {
    loopLines.push("// No operations defined");
  }

  // Build complete code with nice formatting
  const code = `// Generated by Arduino Visual Scripting
// Date: ${new Date().toISOString()}
// Nodes: ${graph.nodes.length}, Edges: ${graph.edges.length}

void setup() {
${setupLines.map((l) => "  " + l).join("\n")}
}

void loop() {
${loopLines.map((l) => "  " + l).join("\n")}
}`;

  return code;
}

/**
 * Generate a simple example sketch for testing
 */
export function generateExampleSketch(): string {
  return `// Arduino Blink Example
// This is a simple test sketch to verify upload

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);  // Usually pin 13
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}`;
}

/**
 * Validate generated Arduino code (basic syntax check)
 */
export function validateArduinoCode(code: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check for required functions
  if (!code.includes("void setup()")) {
    errors.push("Missing setup() function");
  }
  
  if (!code.includes("void loop()")) {
    errors.push("Missing loop() function");
  }
  
  // Check for common syntax errors
  const openBraces = (code.match(/{/g) || []).length;
  const closeBraces = (code.match(/}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unmatched braces: ${openBraces} open, ${closeBraces} close`);
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
