import type { Graph, Node, NodeType } from "@/types/graph";
import { topologicalSort } from "@/utils/helpers";

function pinModes(nodes: Node[]): Map<number, "INPUT" | "OUTPUT"> {
  const pins = new Map<number, "INPUT" | "OUTPUT">();
  for (const n of nodes) {
    if (n.type === "DigitalWrite") {
      const pin = n.payload.pin;
      pins.set(pin, "OUTPUT");
    }
    if (n.type === "AnalogRead") {
      const pin = n.payload.pin;
      if (!pins.has(pin)) pins.set(pin, "INPUT");
    }
  }
  return pins;
}

function emitNode(n: Node): string {
  switch (n.type) {
    case "DigitalWrite":
      return `digitalWrite(${n.payload.pin}, ${n.payload.value ? 1 : 0});`;
    case "AnalogRead":
      return `int ${n.id}_val = analogRead(${n.payload.pin});`;
    case "Delay":
      return `delay(${n.payload.ms});`;
    case "If":
      return `if (${n.payload.condition}) { /* TODO: nested graph */ }`;
    case "Loop":
      return `/* Loop marker: operations below run in loop */`;
    default:
      return `/* Unknown node */`;
  }
}

export function generateArduinoCode(graph: Graph): string {
  if (!graph.nodes || graph.nodes.length === 0) {
    return `// Generated by Arduino Visual Scripting\n// Add nodes to generate code\n\nvoid setup() {\n  // Initialize pins here\n}\n\nvoid loop() {\n  // Your code will appear here\n}`;
  }

  const sorted = topologicalSort(graph.nodes, graph.edges);
  const pins = pinModes(graph.nodes);

  const setupLines: string[] = [];
  for (const [pin, mode] of pins) {
    setupLines.push(`pinMode(${pin}, ${mode});`);
  }

  const loopLines: string[] = [];
  for (const n of sorted) {
    loopLines.push(emitNode(n));
  }

  const code = `// Generated by Arduino Visual Scripting\n\nvoid setup() {\n${setupLines.length > 0 ? setupLines.map((l) => "  " + l).join("\n") : "  // No setup required"}\n}\n\nvoid loop() {\n${loopLines.length > 0 ? loopLines.map((l) => "  " + l).join("\n") : "  // Add nodes to generate code"}\n}`;
  return code;
}
